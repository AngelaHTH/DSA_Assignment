# left with additional feature the open ai
# ensure that biometric feature that is working
# ensure that all important data is encrypted and decrypted
# for password ensure that its hashed and encrypted so that its secure then decrypted when needed
# make it on a web interface for both admin and employee side
# check for real time dashboard ( using flask, js and ensure )
import os
import sys
import re
import shelve
import json
import heapq
import getpass
import logging
from logging.handlers import RotatingFileHandler
from rich.console import Console
from rich.table import Table
import pyfiglet
from tabulate import tabulate
import pandas as pd
from fpdf import FPDF
import matplotlib.pyplot as plt
from io import BytesIO
import base64
from datetime import datetime, timedelta
from cryptography.fernet import Fernet
import bcrypt
import openai
from typing import List, Dict, Optional
import google.generativeai as genai


@app.route('/')
def index():
    return app.send_static_file('index.html')


# Biometric Auth Endpoints
@app.route('/api/biometric/challenge')
def get_challenge():
    challenge = secrets.token_bytes(32)  # Generate a random challenge
    return jsonify({"challenge": list(challenge)})  # Convert bytes to list for JSON


@app.route('/api/biometric/verify', methods=['POST'])
def verify_credential():
    credential = request.json.get('credential')
    # Verify credential (pseudo-code)
    is_valid = verify_biometric_credential(credential)
    if is_valid:
        token = generate_jwt_token()
        return jsonify({"success": True, "token": token})
    return jsonify({"error": "Verification failed"}), 401


# Dashboard Data Endpoint
@app.route('/api/dashboard')
def get_dashboard_data():
    return jsonify({
        "employee_stats": {},  # Replace with real data
        "program_stats": {},
        "request_stats": {}
    })


# Initialize rich console with wider display
console = Console(width=140)  # Increased width to prevent truncation


class BiometricAuth:
    """Simulated biometric authentication system"""

    def __init__(self, system):
        self.system = system
        self.facial_profiles = {}  # In a real system, this would use proper storage

    def enroll_user(self, employee_id):
        """Simulate facial enrollment process"""
        console.print("\n[bold blue]Biometric Enrollment[/bold blue]")
        console.print("1. Use sample image\n2. Capture from camera (simulated)")

        choice = self.system.get_input("Select option: ")
        if choice == '1':
            # Generate a simulated facial profile
            profile = f"simulated_profile_{employee_id}"
            self.facial_profiles[employee_id] = profile
            console.print("[green]Biometric profile created successfully![/green]")
            return True
        elif choice == '2':
            console.print("[yellow]Camera capture simulated - using default profile[/yellow]")
            profile = f"simulated_profile_{employee_id}"
            self.facial_profiles[employee_id] = profile
            console.print("[green]Biometric profile created successfully![/green]")
            return True
        else:
            console.print("[red]Invalid option[/red]")
            return False

    def authenticate(self, employee_id):
        """Simulate facial recognition authentication"""
        if employee_id not in self.facial_profiles:
            console.print("[red]No biometric profile found. Please enroll first.[/red]")
            return False

        console.print("\n[bold blue]Biometric Authentication[/bold blue]")
        console.print("Looking at camera... (simulated)")

        # Simulate matching (80% success rate)
        import random
        if random.random() < 0.8:
            console.print("[green]Authentication successful![/green]")
            return True
        else:
            console.print("[red]Authentication failed. Try again or use password.[/red]")
            return False


# Configure logging
def setup_logging():
    if not os.path.exists('logs'):
        os.makedirs('logs')

    # System logger
    system_logger = logging.getLogger('system')
    system_logger.setLevel(logging.INFO)

    # Action logger
    action_logger = logging.getLogger('actions')
    action_logger.setLevel(logging.INFO)

    # Rotating handler for system logs
    system_handler = RotatingFileHandler(
        'logs/system.log', maxBytes=1024 * 1024, backupCount=5
    )

    # File handler for action logs
    action_handler = logging.FileHandler('logs/employee.log.txt')

    # Formatters
    system_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    action_formatter = logging.Formatter(
        '%(asctime)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    system_handler.setFormatter(system_formatter)
    action_handler.setFormatter(action_formatter)

    system_logger.addHandler(system_handler)
    action_logger.addHandler(action_handler)

    return system_logger, action_logger


system_logger, action_logger = setup_logging()


class SecureDataHandler:
    def __init__(self):
        self.encryption_key = os.getenv('ENCRYPTION_KEY')
        if not self.encryption_key:
            raise ValueError("Encryption key not configured")
        self.cipher = Fernet(self.encryption_key)

    def encrypt(self, data: str) -> str:
        return self.cipher.encrypt(data.encode()).decode()

    def decrypt(self, encrypted_data: str) -> str:
        return self.cipher.decrypt(encrypted_data.encode()).decode()

    @staticmethod
    def hash_password(password: str) -> str:
        return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()

    @staticmethod
    def check_password(hashed: str, password: str) -> bool:
        return bcrypt.checkpw(password.encode(), hashed.encode())

class Employee:
    def __init__(self, name, employee_id, email, department, full_time_status, enrolled_programmes=None):
        self.name = name
        self.employee_id = employee_id
        self.email = email.lower()  # Store email in lowercase
        self.department = department
        self.full_time_status = full_time_status
        self.enrolled_programmes = enrolled_programmes if enrolled_programmes else []
        self.password = None
        self.feedback = []
        self.pending_requests = []

    def add_training_programme(self, programme):
        programme_lower = programme.lower()
        if not any(p.lower() == programme_lower for p in self.enrolled_programmes):
            self.enrolled_programmes.append(programme)
            action_logger.info(f"Employee {self.employee_id} enrolled in {programme}")
            return True
        return False

    def remove_training_programme(self, programme):
        programme_lower = programme.lower()
        for i, prog in enumerate(self.enrolled_programmes):
            if prog.lower() == programme_lower:
                self.enrolled_programmes.pop(i)
                action_logger.info(f"Employee {self.employee_id} removed from {programme}")
                return True
        return False

    def display_details(self):
        status = "Full-time" if self.full_time_status else "Part-time"
        programmes = "\n".join(self.enrolled_programmes) if self.enrolled_programmes else "None"

        table = Table(title=f"Employee Details - {self.name}", show_header=True, header_style="bold blue", expand=True)
        table.add_column("Field", style="dim", width=20)
        table.add_column("Value", width=60)

        table.add_row("Employee ID", str(self.employee_id))
        table.add_row("Name", self.name)
        table.add_row("Email", self.email)
        table.add_row("Department", self.department)
        table.add_row("Status", status)
        table.add_row("Programmes", programmes)

        console.print(table)

    def add_feedback(self, programme, feedback_text, rating):
        feedback_entry = {
            'programme': programme,
            'feedback': feedback_text,
            'rating': rating,
            'date': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        self.feedback.append(feedback_entry)
        action_logger.info(f"Employee {self.employee_id} submitted feedback for {programme}")

    def request_enrollment(self, programme):
        programme_lower = programme.lower()
        if (not any(p.lower() == programme_lower for p in self.enrolled_programmes) and
                not any(req['programme'].lower() == programme_lower for req in self.pending_requests)):
            self.pending_requests.append({
                'programme': programme,
                'date': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                'status': 'Pending'
            })
            action_logger.info(f"Employee {self.employee_id} requested enrollment in {programme}")
            return True
        return False

    def to_dict(self):
        return {
            'name': self.name,
            'employee_id': self.employee_id,
            'email': self.email,
            'department': self.department,
            'full_time_status': self.full_time_status,
            'enrolled_programmes': self.enrolled_programmes,
            'password': self.password,
            'feedback': self.feedback,
            'pending_requests': self.pending_requests
        }


class EmployeeRequest:
    def __init__(self, employee_id, request_type, priority_level, request_details):
        self.employee_id = employee_id
        self.request_type = request_type
        self.priority_level = priority_level
        self.request_details = request_details
        self.timestamp = datetime.now()

    def __lt__(self, other):
        """Comparison for priority queue - lower priority_level comes first, then older timestamp"""
        if self.priority_level == other.priority_level:
            return self.timestamp < other.timestamp
        return self.priority_level < other.priority_level

    def __repr__(self):
        return (f"EmployeeRequest(employee_id={self.employee_id}, type={self.request_type}, "
                f"priority={self.priority_level}, details={self.request_details}, "
                f"timestamp={self.timestamp.strftime('%Y-%m-%d %H:%M:%S')})")


class EmployeeRequestQueue:
    def __init__(self):
        self.requests = []
        self.processed_requests = []

    def add_request(self, request):
        heapq.heappush(self.requests, request)

    def get_next_request(self):
        if self.requests:
            return heapq.heappop(self.requests)
        return None

    def peek_next_request(self):
        if self.requests:
            return self.requests[0]
        return None

    def is_empty(self):
        return len(self.requests) == 0

    def size(self):
        return len(self.requests)

    def get_requests_by_type(self, request_type):
        return [req for req in self.requests if req.request_type == request_type]

    def get_requests_by_priority(self, priority_level):
        return [req for req in self.requests if req.priority_level == priority_level]


class RequestHistory:
    """Stack-based undo/redo system for employee requests with enhanced functionality"""

    def __init__(self):
        """Initialize with empty undo and redo stacks"""
        self.undo_stack = []
        self.redo_stack = []
        self.max_stack_size = 50  # Prevent memory issues

    def record_action(self, action_type: str, request: EmployeeRequest):
        """Record an action for potential undo with size limits

        Args:
            action_type: Type of action ('add' or 'process')
            request: The EmployeeRequest object being acted upon
        """
        if len(self.undo_stack) >= self.max_stack_size:
            self.undo_stack.pop(0)  # Remove oldest action if stack is full
        self.undo_stack.append((action_type, request))
        self.redo_stack = []  # Clear redo stack on new action
        system_logger.info(f"Recorded action: {action_type} for request {request}")

    def undo(self, request_queue: EmployeeRequestQueue) -> bool:
        """Undo the last action with enhanced error handling

        Args:
            request_queue: The queue to perform undo operations on

        Returns:
            bool: True if undo was successful, False otherwise
        """
        try:
            if not self.undo_stack:
                console.print("[yellow]Nothing to undo.[/yellow]")
                return False

            action_type, request = self.undo_stack.pop()
            system_logger.info(f"Undoing action: {action_type} for request {request}")

            if action_type == 'add':
                # Remove the request (if still in queue)
                if request in request_queue.requests:
                    request_queue.requests.remove(request)
                    heapq.heapify(request_queue.requests)
                self.redo_stack.append(('remove', request))
            elif action_type == 'process':
                # Re-add the processed request
                request_queue.add_request(request)
                self.redo_stack.append(('add', request))
            else:
                raise ValueError(f"Unknown action type: {action_type}")

            console.print("[green]Undo successful![/green]")
            return True

        except Exception as e:
            system_logger.error(f"Undo failed: {str(e)}")
            console.print("[red]Error during undo operation.[/red]")
            return False

    def redo(self, request_queue: EmployeeRequestQueue) -> bool:
        """Redo the last undone action with enhanced error handling

        Args:
            request_queue: The queue to perform redo operations on

        Returns:
            bool: True if redo was successful, False otherwise
        """
        try:
            if not self.redo_stack:
                console.print("[yellow]Nothing to redo.[/yellow]")
                return False

            action_type, request = self.redo_stack.pop()
            system_logger.info(f"Redoing action: {action_type} for request {request}")

            if action_type == 'remove':
                request_queue.add_request(request)
                self.undo_stack.append(('add', request))
            elif action_type == 'add':
                if request in request_queue.requests:
                    request_queue.requests.remove(request)
                    heapq.heapify(request_queue.requests)
                self.undo_stack.append(('process', request))
            else:
                raise ValueError(f"Unknown action type: {action_type}")

            console.print("[green]Redo successful![/green]")
            return True

        except Exception as e:
            system_logger.error(f"Redo failed: {str(e)}")
            console.print("[red]Error during redo operation.[/red]")
            return False


class DepartmentTreeNode:
    """Tree node representing department hierarchy"""

    def __init__(self, name, parent=None):
        self.name = name
        self.parent = parent
        self.children = []
        self.employees = []

    def add_child(self, child_name):
        """Add a child department node"""
        child = DepartmentTreeNode(child_name, self)
        self.children.append(child)
        return child

    def add_employee(self, employee):
        """Add employee to this department node"""
        self.employees.append(employee)

    def find_department(self, dept_name):
        """Find department node by name (BFS search)"""
        from collections import deque
        queue = deque()
        queue.append(self)

        while queue:
            current = queue.popleft()
            if current.name.lower() == dept_name.lower():
                return current
            for child in current.children:
                queue.append(child)
        return None

    def print_tree(self, level=0):
        """Print department tree structure"""
        prefix = "    " * level
        console.print(f"{prefix}└─ {self.name} ({len(self.employees)} employees)")
        for child in self.children:
            child.print_tree(level + 1)


class ProgrammeEnrollmentNode:
    """Node for linked list tracking enrollment history"""

    def __init__(self, programme_name, enrollment_date, status):
        self.programme_name = programme_name
        self.enrollment_date = enrollment_date
        self.status = status  # 'Enrolled', 'Completed', 'Dropped'
        self.next = None


class ProgrammeHistory:
    """Linked list tracking employee's programme history"""

    def __init__(self):
        self.head = None
        self.tail = None

    def add_enrollment(self, programme_name, status='Enrolled'):
        """Add new enrollment to history"""
        new_node = ProgrammeEnrollmentNode(
            programme_name,
            datetime.now(),
            status
        )

        if not self.head:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            self.tail = new_node

    def display_history(self):
        """Display enrollment history"""
        current = self.head
        table = Table(show_header=True, header_style="bold blue")
        table.add_column("Programme")
        table.add_column("Date")
        table.add_column("Status")

        while current:
            status_color = "green" if current.status == "Completed" else "yellow" if current.status == "Enrolled" else "red"
            table.add_row(
                current.programme_name,
                current.enrollment_date.strftime("%Y-%m-%d"),
                f"[{status_color}]{current.status}[/{status_color}]"
            )
            current = current.next

        if table.rows:
            console.print(table)
        else:
            console.print("[yellow]No enrollment history found.[/yellow]")


class DataEncryptor:
    """Simple encryption/decryption for sensitive data"""

    def __init__(self, key):
        self.key = key

    def encrypt(self, text):
        """Simple XOR-based encryption"""
        encrypted = []
        key_len = len(self.key)
        for i, char in enumerate(text):
            key_char = self.key[i % key_len]
            encrypted_char = chr(ord(char) ^ ord(key_char))
            encrypted.append(encrypted_char)
        return ''.join(encrypted)

    def decrypt(self, encrypted_text):
        """Decrypt XOR-encrypted text"""
        return self.encrypt(encrypted_text)  # XOR is symmetric


class RealTimeDashboard:
    """Enhanced real-time analytics dashboard with visualizations"""

    def __init__(self, system):
        self.system = system
        self.metrics_history = []
        self.max_history = 100  # Increased history capacity

    def update_metrics(self):
        """Capture comprehensive system metrics"""
        metrics = {
            'timestamp': datetime.now(),
            'total_employees': len(self.system.employees),
            'active_enrollments': sum(len(e.enrolled_programmes) for e in self.system.employees.values()),
            'pending_requests': self.system.request_queue.size(),
            'department_distribution': self._get_department_stats(),
            'program_popularity': self._get_program_stats(),
            'completion_rates': self._get_completion_rates()
        }

        self.metrics_history.append(metrics)
        if len(self.metrics_history) > self.max_history:
            self.metrics_history.pop(0)

        return metrics

    def display_dashboard(self):
        """Display comprehensive dashboard with multiple visualizations"""
        console.print("\n[bold blue]Enhanced Analytics Dashboard[/bold blue]")

        # Key Metrics Summary
        self._display_summary()

        # Time Series Charts
        self._display_enrollment_trend()
        self._display_request_trend()

        # Department Distribution
        self._display_department_chart()

        # Program Popularity
        self._display_program_chart()

        # Completion Rates
        self._display_completion_chart()

    def _display_summary(self):
        """Display key metrics summary"""
        latest = self.metrics_history[-1] if self.metrics_history else {}

        table = Table(show_header=True, header_style="bold blue")
        table.add_column("Metric")
        table.add_column("Value")

        table.add_row("Total Employees", str(latest.get('total_employees', 0)))
        table.add_row("Active Enrollments", str(latest.get('active_enrollments', 0)))
        table.add_row("Pending Requests", str(latest.get('pending_requests', 0)))

        console.print(table)

    def _display_enrollment_trend(self):
        """Show enrollment trend over time"""
        if len(self.metrics_history) < 2:
            console.print("[yellow]Not enough data for trends[/yellow]")
            return

        dates = [m['timestamp'] for m in self.metrics_history]
        enrollments = [m['active_enrollments'] for m in self.metrics_history]

        plt.figure(figsize=(10, 4))
        plt.plot(dates, enrollments, marker='o')
        plt.title("Enrollment Trend Over Time")
        plt.xlabel("Date")
        plt.ylabel("Active Enrollments")
        plt.grid(True)

        console.print("\n[bold]Enrollment Trend:[/bold]")
        console.print(self._plot_to_console(plt))
        plt.close()

    def _display_department_chart(self):
        """Show department distribution"""
        latest = self.metrics_history[-1] if self.metrics_history else {}
        dept_stats = latest.get('department_distribution', {})

        if not dept_stats:
            return

        departments = list(dept_stats.keys())
        counts = list(dept_stats.values())

        plt.figure(figsize=(10, 4))
        plt.bar(departments, counts)
        plt.title("Employee Distribution by Department")
        plt.xlabel("Department")
        plt.ylabel("Number of Employees")
        plt.xticks(rotation=45)

        console.print("\n[bold]Department Distribution:[/bold]")
        console.print(self._plot_to_console(plt))
        plt.close()

    def _plot_to_console(self, plt):
        """Convert matplotlib plot to console display"""
        buf = BytesIO()
        plt.savefig(buf, format='png')
        buf.seek(0)
        img_str = base64.b64encode(buf.read()).decode()
        return f"data:image/png;base64,{img_str}"  # Can be displayed in compatible terminals

    def display_trends(self):
        """Display metric trends over time"""
        if len(self.metrics_history) < 2:
            console.print("[yellow]Not enough data to show trends yet.[/yellow]")
            return

        # Prepare trend data
        timestamps = [m['timestamp'].strftime("%H:%M") for m in self.metrics_history]
        employees = [m['total_employees'] for m in self.metrics_history]
        enrollments = [m['active_enrollments'] for m in self.metrics_history]
        requests = [m['pending_requests'] for m in self.metrics_history]

        # Create trend visualization
        console.print("\n[bold blue]System Trends[/bold blue]")

        # Employee growth
        console.print("\n[bold]Employee Growth:[/bold]")
        self._plot_sparkline(employees, timestamps)

        # Enrollment trends
        console.print("\n[bold]Program Enrollment Trends:[/bold]")
        self._plot_sparkline(enrollments, timestamps)

        # Request queue trends
        console.print("\n[bold]Pending Requests Trends:[/bold]")
        self._plot_sparkline(requests, timestamps)

    def _plot_sparkline(self, data, labels):
        """Helper to display simple sparkline graphs"""
        if not data:
            return

        min_val = min(data)
        max_val = max(data)
        range_val = max_val - min_val if max_val != min_val else 1

        # Normalize data to 0-10 range
        normalized = [int(10 * (x - min_val) / range_val) for x in data]

        # Sparkline characters
        spark_chars = "▁▂▃▄▅▆▇█"

        # Build sparkline
        sparkline = ''.join([spark_chars[min(v, len(spark_chars) - 1)] for v in normalized])

        # Display with min/max values
        console.print(f"{sparkline}  [dim](Min: {min_val}, Max: {max_val})[/dim]")



class ProgramAdvisor:
    """AI-powered program advisor using Gemini API with fallback to local knowledge"""

    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key
        self.api_available = False
        self.model = "gemini-pro"  # Free tier model

        # Enhanced local knowledge base
        self.knowledge_base = {
            "technical": [
                "Python Programming Fundamentals",
                "Advanced Data Structures and Algorithms",
                "Machine Learning Basics",
                "Cloud Computing Essentials",
                "Cybersecurity Fundamentals"
            ],
            "management": [
                "Project Management Professional (PMP)",
                "Agile Scrum Master Certification",
                "Leadership and Team Management",
                "Business Communication Skills",
                "Strategic Planning Workshop"
            ],
            "creative": [
                "Graphic Design Principles",
                "Digital Marketing Fundamentals",
                "Content Writing Masterclass",
                "Video Editing Basics",
                "Social Media Marketing"
            ]
        }

        if api_key:
            self._initialize_gemini()

    def _initialize_gemini(self):
        """Initialize Gemini API connection"""
        try:
            genai.configure(api_key=self.api_key)
            # Test connection with a simple request
            model = genai.GenerativeModel(self.model)
            model.generate_content("Test connection")
            self.api_available = True
            logging.info("Gemini API successfully initialized")
        except Exception as e:
            self.api_available = False
            logging.warning(f"Gemini API connection failed: {str(e)}")
            console.print("\n[yellow]Warning: AI service unavailable. Using local recommendations.[/yellow]")

    def get_recommendations(self, employee: 'Employee', query: str = None) -> List[str]:
        """
        Get program recommendations using AI or fallback to local knowledge
        Returns: List of recommended programs
        """
        if self.api_available and query:
            try:
                return self._get_ai_recommendations(employee, query)
            except Exception as e:
                logging.error(f"AI recommendation failed: {str(e)}")
                console.print("[yellow]Falling back to local recommendations[/yellow]")

        return self._get_local_recommendations(employee, query)

    def _get_ai_recommendations(self, employee: 'Employee', query: str) -> List[str]:
        """Get recommendations from Gemini API"""
        try:
            model = genai.GenerativeModel(self.model)

            prompt = self._build_prompt(employee, query)

            response = model.generate_content(
                prompt,
                generation_config={
                    "temperature": 0.7,
                    "max_output_tokens": 500,
                }
            )

            return self._parse_response(response.text)
        except Exception as e:
            logging.error(f"AI recommendation error: {str(e)}")
            raise

    def _build_prompt(self, employee: 'Employee', query: str) -> str:
        """Construct the prompt for Gemini"""
        base_prompt = f"""
        You are a career advisor for {employee.name}, who works in {employee.department}.
        Current skills: {', '.join(self._infer_skills(employee))}
        Current programs enrolled: {', '.join(employee.enrolled_programmes) if employee.enrolled_programmes else 'None'}

        """

        if query:
            return base_prompt + f"""
            The employee asks: "{query}"

            Please provide 3-5 relevant training program recommendations that would help them 
            advance in their career. For each recommendation, include a brief explanation 
            (1 sentence) of why it would be beneficial.

            Format your response with one recommendation per line, like this:
            1. Recommendation 1 - Brief reason
            2. Recommendation 2 - Brief reason
            """

        return base_prompt + """
        Please suggest 3-5 training programs that would be most beneficial for this employee
        based on their current role and skills. For each recommendation, include a brief
        explanation (1 sentence) of why it would be beneficial.

        Format your response with one recommendation per line, like this:
        1. Recommendation 1 - Brief reason
        2. Recommendation 2 - Brief reason
        """

    def _parse_response(self, response: str) -> List[str]:
        """Parse the AI response into a list of recommendations"""
        if not response:
            return []

        # Extract numbered recommendations
        recommendations = []
        for line in response.split('\n'):
            line = line.strip()
            if line and (line[0].isdigit() or line.startswith('-')):
                # Remove numbering/bullets and any trailing explanation
                rec = line.split('. ')[-1].split(' - ')[0]
                if rec:
                    recommendations.append(rec)

        return recommendations[:5]  # Return max 5 recommendations

    def _get_local_recommendations(self, employee: 'Employee', query: str = None) -> List[str]:
        """Fallback to local knowledge base recommendations"""
        department = employee.department.lower()
        current_programs = [p.lower() for p in employee.enrolled_programmes]

        # Determine category based on department
        if "tech" in department or "it" in department:
            category = "technical"
        elif "manage" in department or "lead" in department:
            category = "management"
        else:
            category = "creative"

        # Get relevant programs not already enrolled
        recommendations = [
            p for p in self.knowledge_base.get(category, [])
            if p.lower() not in current_programs
        ]

        # If there's a query, sort by relevance
        if query:
            query = query.lower()
            recommendations.sort(
                key=lambda p: self._similarity_score(query, p.lower()),
                reverse=True
            )

        return recommendations[:3]  # Return max 3 local recommendations

    def _infer_skills(self, employee: 'Employee') -> List[str]:
        """Infer skills from enrolled programs"""
        skill_map = {
            "python": "Python Programming",
            "data": "Data Analysis",
            "machine": "Machine Learning",
            "project": "Project Management",
            "agile": "Agile Methodologies",
            "design": "Design Skills",
            "cloud": "Cloud Computing",
            "security": "Cybersecurity"
        }

        skills = set()
        for program in employee.enrolled_programmes:
            program_lower = program.lower()
            for keyword, skill in skill_map.items():
                if keyword in program_lower:
                    skills.add(skill)
        return list(skills)

    def _similarity_score(self, query: str, text: str) -> float:
        """Simple similarity scoring between query and text"""
        query_words = set(query.lower().split())
        text_words = set(text.lower().split())
        common = query_words & text_words
        return len(common) / len(query_words) if query_words else 0

    def interactive_chat(self, system, employee: 'Employee'):
        """Interactive chat interface for program advice"""
        console.print("\n[bold blue]AI Program Advisor[/bold blue]")

        if self.api_available:
            console.print("[dim]AI-powered advisor (type 'exit' to end)[/dim]\n")
        else:
            console.print("[yellow]Using local knowledge base[/yellow]")
            console.print("[dim]Basic advisor (type 'exit' to end)[/dim]\n")

        while True:
            query = system.get_input("You: ")
            if not query or query.lower() == 'exit':
                break

            recommendations = self.get_recommendations(employee, query)

            if recommendations:
                console.print("\n[bold]Recommended Programs:[/bold]")
                for i, rec in enumerate(recommendations, 1):
                    console.print(f"{i}. {rec}")
            else:
                console.print("\n[yellow]No recommendations found.[/yellow]")


class TrainingManagementSystem:
    def __init__(self):
        self.employees = {}
        self.logged_in_user = None
        self.admin_username = "admin"
        self.admin_password = "admin123"
        self.request_queue = EmployeeRequestQueue()
        self.request_history = RequestHistory()
        self.department_tree = self._build_department_tree()
        self.real_time_dashboard = RealTimeDashboard(self)
        self.biometric_auth = BiometricAuth(self)
        self.encryptor = DataEncryptor(os.getenv("ENCRYPTION_KEY", "default_system_key_123"))
        self.load_data()
        self.biometric_auth = BiometricAuth(self)
        self.encryptor = DataEncryptor(os.getenv("ENCRYPTION_PASSWORD"))
        self.program_advisor = ProgramAdvisor(os.getenv("AIzaSyDaKTosDT12wy6fMl3bGZCaB3OApFUi8-M"))
        system_logger.info("System initialized")

    def _build_department_tree(self):
        """Build department hierarchy tree"""
        root = DepartmentTreeNode("Organization")

        # Sample department structure - could be loaded from config
        hr = root.add_child("Human Resources")
        hr.add_child("Recruitment")
        hr.add_child("Employee Development")

        it = root.add_child("Information Technology")
        it.add_child("Software Development")
        it.add_child("Infrastructure")
        it.add_child("Data Science")

        finance = root.add_child("Finance")
        finance.add_child("Accounting")
        finance.add_child("Financial Planning")

        # Assign employees to departments
        for emp in self.employees.values():
            dept_node = root.find_department(emp.department)
            if dept_node:
                dept_node.add_employee(emp)
            else:
                # Auto-create department if not found
                new_dept = root.add_child(emp.department)
                new_dept.add_employee(emp)

        return root

    def save_data(self):
        """Save employee data to disk with comprehensive error handling"""
        try:
            # Ensure directory exists
            os.makedirs('data', exist_ok=True)

            # Use context manager for safe file handling
            with shelve.open('data/employee_data') as db:
                # Create a deep copy to avoid modification during save
                data_to_save = {eid: emp.to_dict() for eid, emp in self.employees.items()}
                db['employees'] = data_to_save

                # Verify write was successful
                if 'employees' not in db:
                    raise IOError("Data not saved correctly")

            system_logger.info("Data saved successfully")

        except PermissionError:
            error_msg = "Permission denied when saving data"
            system_logger.error(error_msg)
            console.print(f"[red]{error_msg}. Please check file permissions.[/red]")
        except IOError as e:
            error_msg = f"I/O error saving data: {str(e)}"
            system_logger.error(error_msg)
            console.print(f"[red]{error_msg}[/red]")
        except Exception as e:
            error_msg = f"Unexpected error saving data: {str(e)}"
            system_logger.error(error_msg)
            console.print(f"[red]{error_msg}[/red]")

    def load_data(self):
        """Load employee data from disk with comprehensive error handling"""
        try:
            # Verify file exists before trying to open
            if not os.path.exists('data/employee_data.dat'):
                system_logger.info("No existing data file found, starting fresh")
                return

            with shelve.open('data/employee_data', flag='r') as db:
                if 'employees' not in db:
                    system_logger.warning("Data file exists but no employee data found")
                    return

                employees_data = db['employees']

                # Validate loaded data structure
                if not isinstance(employees_data, dict):
                    raise ValueError("Invalid data format in save file")

                # Load data with validation
                for eid, emp_data in employees_data.items():
                    try:
                        # Validate required fields
                        required_fields = ['name', 'employee_id', 'email', 'department', 'full_time_status']
                        if not all(field in emp_data for field in required_fields):
                            raise ValueError(f"Missing required fields in employee data for ID {eid}")

                        employee = Employee(
                            emp_data['name'],
                            int(eid),
                            emp_data['email'],
                            emp_data['department'],
                            emp_data['full_time_status'],
                            emp_data.get('enrolled_programmes', [])
                        )
                        employee.password = emp_data.get('password')
                        employee.feedback = emp_data.get('feedback', [])
                        employee.pending_requests = emp_data.get('pending_requests', [])
                        self.employees[int(eid)] = employee

                    except (ValueError, KeyError) as e:
                        system_logger.error(f"Error loading employee {eid}: {str(e)}")
                        continue

            system_logger.info(f"Successfully loaded {len(self.employees)} employees")

        except PermissionError:
            error_msg = "Permission denied when loading data"
            system_logger.error(error_msg)
            console.print(f"[red]{error_msg}. Please check file permissions.[/red]")
        except Exception as e:
            error_msg = f"Error loading data: {str(e)}"
            system_logger.error(error_msg)
            console.print(f"[red]{error_msg}[/red]")
            # Start with empty dataset if load fails
            self.employees = {}

    # Quick Sort Implementation
    def quick_sort_employees(self, employees):
        """Quick sort implementation for employees by department (ascending) and name (ascending)"""
        if len(employees) <= 1:
            return employees

        pivot = employees[len(employees) // 2]
        left = [emp for emp in employees if
                (emp.department < pivot.department) or
                (emp.department == pivot.department and emp.name < pivot.name)]
        middle = [emp for emp in employees if
                  emp.department == pivot.department and emp.name == pivot.name]
        right = [emp for emp in employees if
                 (emp.department > pivot.department) or
                 (emp.department == pivot.department and emp.name > pivot.name)]

        return self.quick_sort_employees(left) + middle + self.quick_sort_employees(right)

    def display_sorted_by_department(self):
        """Display employees sorted by department and name using quick sort"""
        console.print("\n[bold blue]Employees Sorted by Department and Name (Quick Sort)[/bold blue]")

        # Get all employees and sort them
        employee_list = list(self.employees.values())
        sorted_employees = self.quick_sort_employees(employee_list)

        # Display results in tabular format
        table = Table(show_header=True, header_style="bold blue", show_lines=True)
        table.add_column("ID", style="dim", width=10)
        table.add_column("Name", width=20)
        table.add_column("Department", width=20)
        table.add_column("Status", width=12)
        table.add_column("Programmes", width=30)

        for emp in sorted_employees:
            status = "Full-time" if emp.full_time_status else "Part-time"
            programmes = ", ".join(emp.enrolled_programmes) if emp.enrolled_programmes else "None"
            table.add_row(
                str(emp.employee_id),
                emp.name,
                emp.department,
                status,
                programmes
            )

        console.print(table)
        action_logger.info("Displayed employees sorted by department and name using quick sort")

    # Merge Sort Implementation
    def merge_sort_employees(self, employees):
        """Merge sort implementation for employees by num of programmes and ID"""
        if len(employees) <= 1:
            return employees

        mid = len(employees) // 2
        left = self.merge_sort_employees(employees[:mid])
        right = self.merge_sort_employees(employees[mid:])

        return self.merge(left, right)

    def merge(self, left, right):
        """Merge helper function for merge sort"""
        result = []
        i = j = 0

        while i < len(left) and j < len(right):
            # Sort by number of programmes (ascending), then by employee ID (ascending)
            if len(left[i].enrolled_programmes) < len(right[j].enrolled_programmes):
                result.append(left[i])
                i += 1
            elif len(left[i].enrolled_programmes) > len(right[j].enrolled_programmes):
                result.append(right[j])
                j += 1
            else:  # If same number of programmes, sort by ID
                if left[i].employee_id < right[j].employee_id:
                    result.append(left[i])
                    i += 1
                else:
                    result.append(right[j])
                    j += 1

        result.extend(left[i:])
        result.extend(right[j:])
        return result

    def display_sorted_by_programmes(self):
        """Display employees sorted by number of programmes and ID using merge sort"""
        console.print("\n[bold blue]Employees Sorted by Programmes and ID (Merge Sort)[/bold blue]")

        # Get all employees and sort them
        employee_list = list(self.employees.values())
        sorted_employees = self.merge_sort_employees(employee_list)

        # Display results in tabular format
        table = Table(show_header=True, header_style="bold blue", show_lines=True)
        table.add_column("ID", style="dim", width=10)
        table.add_column("Name", width=20)
        table.add_column("Department", width=20)
        table.add_column("# Programmes", width=12)
        table.add_column("Programmes", width=30)

        for emp in sorted_employees:
            table.add_row(
                str(emp.employee_id),
                emp.name,
                emp.department,
                str(len(emp.enrolled_programmes)),
                ", ".join(emp.enrolled_programmes) if emp.enrolled_programmes else "None"
            )

        console.print(table)
        action_logger.info("Displayed employees sorted by programmes and ID using merge sort")

        # Add department filter option
        self.filter_by_department(sorted_employees)

    def filter_by_department(self, employees):
        """Filter the sorted list by department"""
        departments = sorted(set(emp.department for emp in employees))

        console.print("\n[bold]Available Departments:[/bold]")
        for i, dept in enumerate(departments, 1):
            console.print(f"{i}. {dept}")

        choice = self.get_input("\nSelect department to filter (number) or press Enter to skip: ")
        if not choice:
            return

        try:
            dept_idx = int(choice) - 1
            if 0 <= dept_idx < len(departments):
                selected_dept = departments[dept_idx]
                filtered = [emp for emp in employees if emp.department == selected_dept]

                console.print(f"\n[bold]{selected_dept} Department Employees:[/bold]")

                table = Table(show_header=True, header_style="bold blue", show_lines=True)
                table.add_column("ID", style="dim", width=10)
                table.add_column("Name", width=20)
                table.add_column("# Programmes", width=12)
                table.add_column("Programmes", width=30)

                for emp in filtered:
                    table.add_row(
                        str(emp.employee_id),
                        emp.name,
                        str(len(emp.enrolled_programmes)),
                        ", ".join(emp.enrolled_programmes) if emp.enrolled_programmes else "None"
                    )

                console.print(table)
                action_logger.info(f"Filtered employees by department: {selected_dept}")
            else:
                console.print("[red]Invalid department selection.[/red]")
        except ValueError:
            console.print("[red]Please enter a valid number.[/red]")

    # Employee Request Management
    def validate_employee_id_for_request(self, employee_id):
        """Validate employee ID exists using binary search"""
        sorted_ids = sorted(self.employees.keys())
        low = 0
        high = len(sorted_ids) - 1

        while low <= high:
            mid = (low + high) // 2
            if sorted_ids[mid] == employee_id:
                return True
            elif sorted_ids[mid] < employee_id:
                low = mid + 1
            else:
                high = mid - 1

        return False

    def add_employee_request(self):
        """Add a new employee request to the priority queue"""
        console.print("\n[bold blue]Add Employee Request[/bold blue]")

        # Employee ID validation
        while True:
            employee_id = self.get_input("Enter employee ID (or 'back' to cancel): ", required=True)
            if employee_id is None:
                return

            try:
                employee_id = int(employee_id)

                # Binary search validation
                if not self.validate_employee_id_for_request(employee_id):
                    console.print("[red]Employee ID not found.[/red]")
                    continue

                # If ID exists, prompt for confirmation if duplicate requests exist
                if any(req.employee_id == employee_id for req in self.request_queue.requests):
                    confirm = self.get_input(
                        f"Employee {employee_id} already has pending requests. Continue? (Y/N): ",
                        required=True
                    )
                    if confirm and confirm.upper() != 'Y':
                        continue

                break
            except ValueError:
                console.print("[red]Please enter a valid ID.[/red]")

        # Request type
        request_types = ["Enrollment", "Feedback", "Information", "Technical", "Other"]
        console.print("\n[bold]Request Types:[/bold]")
        for i, req_type in enumerate(request_types, 1):
            console.print(f"{i}. {req_type}")

        while True:
            type_choice = self.get_input("Select request type (1-5): ", required=True)
            if type_choice is None:
                return
            try:
                type_idx = int(type_choice) - 1
                if 0 <= type_idx < len(request_types):
                    request_type = request_types[type_idx]
                    break
                console.print("[red]Invalid selection.[/red]")
            except ValueError:
                console.print("[red]Please enter a number.[/red]")

        # Priority level
        while True:
            priority = self.get_input("Priority level (1-5, 1=highest): ", required=True)
            if priority is None:
                return
            try:
                priority_level = int(priority)
                if 1 <= priority_level <= 5:
                    break
                console.print("[red]Priority must be between 1-5.[/red]")
            except ValueError:
                console.print("[red]Please enter a number.[/red]")

        # Request details
        details = self.get_input("Request details: ", required=True)
        if details is None:
            return

        # Create and add request
        request = EmployeeRequest(employee_id, request_type, priority_level, details)
        self.request_queue.add_request(request)
        self.request_history.record_action('add', request)

        console.print("\n[green]Request added successfully![/green]")
        action_logger.info(f"Added request for employee {employee_id}: {request_type} (Priority: {priority_level})")

        # Show queue position
        console.print(f"\n[dim]Current queue position: {self.request_queue.size()}[/dim]")

    def view_request_statistics(self):
        """Display queue statistics and filtering options"""
        console.print("\n[bold blue]Employee Request Queue Statistics[/bold blue]")

        total_requests = self.request_queue.size()
        console.print(f"\n[bold]Total Requests in Queue:[/bold] {total_requests}")

        if total_requests == 0:
            return

        # Show priority distribution
        console.print("\n[bold]Requests by Priority:[/bold]")
        priority_counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}
        for req in self.request_queue.requests:
            priority_counts[req.priority_level] += 1

        for priority, count in sorted(priority_counts.items()):
            console.print(f"Priority {priority}: {count} request(s)")

        # Show type distribution
        console.print("\n[bold]Requests by Type:[/bold]")
        type_counts = {}
        for req in self.request_queue.requests:
            type_counts[req.request_type] = type_counts.get(req.request_type, 0) + 1

        for req_type, count in sorted(type_counts.items()):
            console.print(f"{req_type}: {count} request(s)")

        # Filtering options
        console.print("\n1. Filter by Request Type\n2. Filter by Priority Level\n3. Back")
        choice = self.get_input("Select option: ")

        if choice == '1':
            request_types = sorted(set(req.request_type for req in self.request_queue.requests))
            console.print("\n[bold]Available Request Types:[/bold]")
            for i, req_type in enumerate(request_types, 1):
                console.print(f"{i}. {req_type}")

            type_choice = self.get_input("Select type to filter (number): ")
            if type_choice:
                try:
                    type_idx = int(type_choice) - 1
                    if 0 <= type_idx < len(request_types):
                        selected_type = request_types[type_idx]
                        filtered = self.request_queue.get_requests_by_type(selected_type)

                        console.print(f"\n[bold]{selected_type} Requests:[/bold]")
                        self.display_requests_table(filtered)
                    else:
                        console.print("[red]Invalid selection.[/red]")
                except ValueError:
                    console.print("[red]Please enter a number.[/red]")

        elif choice == '2':
            priority_choice = self.get_input("Enter priority level to filter (1-5): ")
            if priority_choice:
                try:
                    priority_level = int(priority_choice)
                    if 1 <= priority_level <= 5:
                        filtered = self.request_queue.get_requests_by_priority(priority_level)

                        console.print(f"\n[bold]Priority {priority_level} Requests:[/bold]")
                        self.display_requests_table(filtered)
                    else:
                        console.print("[red]Priority must be 1-5.[/red]")
                except ValueError:
                    console.print("[red]Please enter a number.[/red]")

    def display_requests_table(self, requests):
        """Display requests in a formatted table"""
        if not requests:
            console.print("[yellow]No requests found.[/yellow]")
            return

        # Sort by priority and timestamp
        sorted_requests = sorted(requests, key=lambda x: (x.priority_level, x.timestamp))

        table = Table(show_header=True, header_style="bold blue", show_lines=True)
        table.add_column("Position", style="dim", width=8)
        table.add_column("Employee ID", width=10)
        table.add_column("Type", width=15)
        table.add_column("Priority", width=10)
        table.add_column("Details", width=40)
        table.add_column("Timestamp", width=20)

        for i, req in enumerate(sorted_requests, 1):
            table.add_row(
                str(i),
                str(req.employee_id),
                req.request_type,
                str(req.priority_level),
                req.request_details,
                req.timestamp.strftime("%Y-%m-%d %H:%M:%S")
            )

        console.print(table)

    def process_next_request(self):
        """Process the next request in the priority queue"""
        console.print("\n[bold blue]Process Next Request[/bold blue]")

        if self.request_queue.is_empty():
            console.print("[yellow]No requests in queue.[/yellow]")
            return

        # Peek at next request
        next_request = self.request_queue.peek_next_request()
        self.request_history.record_action('process', next_request)

        console.print("\n[bold]Next Request to Process:[/bold]")

        table = Table(show_header=True, header_style="bold blue", show_lines=True)
        table.add_column("Field", style="dim", width=15)
        table.add_column("Value", width=40)

        employee = self.employees.get(next_request.employee_id, None)
        emp_name = employee.name if employee else "Unknown"

        table.add_row("Employee ID", str(next_request.employee_id))
        table.add_row("Employee Name", emp_name)
        table.add_row("Request Type", next_request.request_type)
        table.add_row("Priority", str(next_request.priority_level))
        table.add_row("Details", next_request.request_details)
        table.add_row("Submitted", next_request.timestamp.strftime("%Y-%m-%d %H:%M:%S"))

        console.print(table)

        # Confirmation
        confirm = self.get_input("\nProcess this request? (Y/N): ", required=True)
        if confirm and confirm.upper() == 'Y':
            # Remove from queue
            processed_request = self.request_queue.get_next_request()

            # Log to file
            self.log_processed_request(processed_request)

            console.print("\n[green]Request processed successfully![/green]")
            console.print(f"[dim]Remaining requests: {self.request_queue.size()}[/dim]")

            # Add to processed requests (for undo functionality)
            self.request_queue.processed_requests.append(processed_request)

            action_logger.info(
                f"Processed request for employee {processed_request.employee_id}: "
                f"{processed_request.request_type} (Priority: {processed_request.priority_level})"
            )
        else:
            console.print("[yellow]Processing cancelled.[/yellow]")

    def log_processed_request(self, request):
        """Log processed request to a file"""
        log_entry = {
            'employee_id': request.employee_id,
            'request_type': request.request_type,
            'priority': request.priority_level,
            'details': request.request_details,
            'timestamp': request.timestamp.strftime("%Y-%m-%d %H:%M:%S"),
            'processed_at': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

        # Ensure logs directory exists
        os.makedirs('logs', exist_ok=True)

        # Append to processed requests log
        log_file = 'logs/processed_requests.log'
        try:
            with open(log_file, 'a') as f:
                f.write(json.dumps(log_entry) + '\n')
        except Exception as e:
            system_logger.error(f"Failed to log processed request: {str(e)}")
            console.print("[red]Error logging request.[/red]")

    def undo_last_action(self):
        """Undo last queue action"""
        if self.request_history.undo(self.request_queue):
            console.print("[green]Undo successful![/green]")
        else:
            console.print("[yellow]Nothing to undo.[/yellow]")

    def redo_last_action(self):
        """Redo last undone action"""
        if self.request_history.redo(self.request_queue):
            console.print("[green]Redo successful![/green]")
        else:
            console.print("[yellow]Nothing to redo.[/yellow]")

    def encrypt_sensitive_data(self, text):
        """Encrypt sensitive text data"""
        return self.encryptor.encrypt(text)

    def decrypt_sensitive_data(self, encrypted_text):
        """Decrypt sensitive text data"""
        return self.encryptor.decrypt(encrypted_text)

    def show_department_hierarchy(self):
        """Display the organizational department tree"""
        console.print("\n[bold blue]Department Hierarchy[/bold blue]")
        self.department_tree.print_tree()

        # Show department selection option
        dept_name = self.get_input("\nEnter department name to view details (or leave blank): ")
        if dept_name:
            dept_node = self.department_tree.find_department(dept_name)
            if dept_node:
                console.print(f"\n[bold]{dept_node.name} Department[/bold]")
                console.print(f"Employees: {len(dept_node.employees)}")

                if dept_node.employees:
                    table = Table(show_header=True, header_style="bold blue")
                    table.add_column("ID")
                    table.add_column("Name")
                    table.add_column("Programmes")

                    for emp in dept_node.employees:
                        table.add_row(
                            str(emp.employee_id),
                            emp.name,
                            ", ".join(emp.enrolled_programmes) if emp.enrolled_programmes else "None"
                        )

                    console.print(table)
            else:
                console.print("[red]Department not found.[/red]")

    def validate_email(self, email):
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not re.match(pattern, email.lower()):
            return False
        return not any(emp.email == email.lower() for emp in self.employees.values())

    def validate_employee_id(self, employee_id):
        return employee_id not in self.employees and len(str(employee_id)) == 5

    def add_employee(self):
        console.print("\n[bold blue]Add New Employee[/bold blue]")
        console.print("[italic]Enter 'back' or '0' at any time to cancel[/italic]\n")

        # Name
        name = self.get_input("Enter employee name: ", required=True)
        if name is None:
            return

        # Employee ID
        while True:
            employee_id = self.get_input("Enter 5-digit employee ID: ", required=True)
            if employee_id is None:
                return
            try:
                employee_id = int(employee_id)
                if self.validate_employee_id(employee_id):
                    break
                console.print("[red]Invalid ID. Either exists or not 5 digits.[/red]")
            except ValueError:
                console.print("[red]Please enter a valid integer.[/red]")

        # Email
        while True:
            email = self.get_input("Enter employee email: ", required=True)
            if email is None:
                return
            if self.validate_email(email):
                break
            console.print("[red]Invalid email format or email already exists.[/red]")

        # Department - removed restrictions
        department = self.get_input("Enter department: ", required=True)
        if department is None:
            return
        department = department.title()  # Just format nicely

        # Status
        while True:
            status = self.get_input("Full-time? (Y/N): ", required=True)
            if status is None:
                return
            status = status.upper()
            if status in ['Y', 'N']:
                full_time = status == 'Y'
                break
            console.print("[red]Please enter Y or N.[/red]")

        new_employee = Employee(name, employee_id, email, department, full_time)
        self.employees[employee_id] = new_employee
        self.save_data()
        action_logger.info(f"Added employee: {name} (ID: {employee_id})")
        console.print(f"\n[green]Employee {name} added successfully![/green]")

    def get_input(self, prompt, required=False, password=False, allow_back=True, input_type=None, min_value=None,
                  max_value=None, max_length=None):
        """Get validated user input with comprehensive validation options

        Args:
            prompt: The prompt to display to the user
            required: Whether input is mandatory
            password: Whether to hide input (for passwords)
            allow_back: Whether to allow 'back' command
            input_type: Expected type (str, int, float, 'email', etc.)
            min_value: Minimum value for numeric inputs
            max_value: Maximum value for numeric inputs
            max_length: Maximum length for string inputs

        Returns:
            Validated user input or None if cancelled
        """
        while True:
            try:
                if password:
                    user_input = getpass.getpass(prompt)
                else:
                    print(prompt, end='', flush=True)
                    user_input = input().strip()

                # Check for back command
                if allow_back and (user_input.lower() == 'back' or user_input == '0'):
                    return None

                # Check required field
                if required and not user_input:
                    console.print("[red]This field is required.[/red]")
                    continue

                # Validate based on input type
                if input_type is not None:
                    if input_type == int:
                        try:
                            user_input = int(user_input)
                            if min_value is not None and user_input < min_value:
                                console.print(f"[red]Value must be at least {min_value}.[/red]")
                                continue
                            if max_value is not None and user_input > max_value:
                                console.print(f"[red]Value must be no more than {max_value}.[/red]")
                                continue
                        except ValueError:
                            console.print("[red]Please enter a valid integer.[/red]")
                            continue

                    elif input_type == float:
                        try:
                            user_input = float(user_input)
                            if min_value is not None and user_input < min_value:
                                console.print(f"[red]Value must be at least {min_value}.[/red]")
                                continue
                            if max_value is not None and user_input > max_value:
                                console.print(f"[red]Value must be no more than {max_value}.[/red]")
                                continue
                        except ValueError:
                            console.print("[red]Please enter a valid number.[/red]")
                            continue

                    elif input_type == 'email':
                        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', user_input):
                            console.print("[red]Please enter a valid email address.[/red]")
                            continue

                    elif input_type == 'name':
                        if not re.match(r'^[a-zA-Z\s\-\.\']+$', user_input):
                            console.print(
                                "[red]Names can only contain letters, spaces, hyphens, and apostrophes.[/red]")
                            continue
                        if max_length and len(user_input) > max_length:
                            console.print(f"[red]Name must be no more than {max_length} characters.[/red]")
                            continue

                # General length validation
                if max_length is not None and len(user_input) > max_length:
                    console.print(f"[red]Input must be no more than {max_length} characters.[/red]")
                    continue

                return user_input

            except EOFError:
                return None
            except KeyboardInterrupt:
                console.print("\n[red]Operation cancelled.[/red]")
                return None

    def display_employee_table(self, employees, extra_columns=None):
        """Helper method to display employee data in consistent tabulate format"""
        # Prepare table data with all information
        table_data = []
        for emp in employees:
            # Get badge information
            try:
                with shelve.open('badges_db', flag='r') as badges_db:
                    badges = badges_db.get(str(emp.employee_id), [])
                    badge_count = len(badges)
                    points = self.calculate_points(badges)
                    badge_names = ", ".join(badges) if badges else "None"
            except:
                badge_count = 0
                points = 0
                badge_names = "None"

            row = [
                emp.employee_id,
                emp.name,
                emp.email,
                "Full-time" if emp.full_time_status else "Part-time",
                emp.department,
                len(emp.enrolled_programmes),
                ", ".join(emp.enrolled_programmes) if emp.enrolled_programmes else "None",
                badge_count,
                points,
                badge_names
            ]

            if extra_columns:
                for col in extra_columns:
                    row.append(col(emp))

            table_data.append(row)

        # Define base headers
        headers = [
            "ID", "Name", "Email", "Status", "Department",
            "Programmes", "Programmes", "Badges", "Points", "Badge Names"
        ]

        if extra_columns:
            headers.extend([col.__name__ for col in extra_columns])

        # Print using tabulate with logging
        action_logger.info("Displayed employee records")
        print(tabulate(table_data, headers=headers, tablefmt="fancy_grid"))

    def display_all_employees(self):
        """Display all employee information including ID, name, email, status, programs, and badges"""
        console.print("\n[bold blue]All Employees[/bold blue]")

        if not self.employees:
            console.print("[yellow]No employees found.[/yellow]")
            action_logger.info("Displayed empty employee list")
            return

        self.display_employee_table(sorted(self.employees.values(), key=lambda x: x.employee_id))

    def enrol_programme(self):
        console.print("[italic]Enter 'back' or '0' at any time to cancel[/italic]\n")
        employee_id = self.select_employee()
        if not employee_id:
            return

        employee = self.employees[employee_id]
        self.display_employee_table([employee])
        action_logger.info(f"Displayed employee {employee_id} for enrollment")

        programme = self.get_input("Enter programme name: ", required=True)
        if not programme:
            return

        if employee.add_training_programme(programme):
            self.save_data()
            action_logger.info(f"Enrolled employee {employee_id} in {programme}")
            console.print(f"\n[green]{employee.name} enrolled in {programme}.[/green]")
            self.display_employee_table([employee])
        else:
            console.print(f"\n[yellow]{employee.name} is already enrolled in this programme.[/yellow]")
            action_logger.info(f"Enrollment failed - already enrolled: {employee_id} in {programme}")

    def unenroll_programme(self):
        console.print("[italic]Enter 'back' or '0' at any time to cancel[/italic]\n")
        employee_id = self.select_employee()
        if not employee_id:
            return

        employee = self.employees[employee_id]
        if not employee.enrolled_programmes:
            console.print("[yellow]Employee is not enrolled in any programmes.[/yellow]")
            return

        console.print("\n[bold]Current Programmes:[/bold]")
        for i, prog in enumerate(employee.enrolled_programmes, 1):
            console.print(f"{i}. {prog}")

        prog_choice = self.get_input("Select programme to unenroll (number): ", required=True)
        if prog_choice is None: return

        try:
            prog_choice = int(prog_choice) - 1
            if 0 <= prog_choice < len(employee.enrolled_programmes):
                programme = employee.enrolled_programmes[prog_choice]
                if employee.remove_training_programme(programme):
                    self.save_data()
                    console.print(f"\n[green]Successfully unenrolled {employee.name} from {programme}.[/green]")
                else:
                    console.print("\n[red]Failed to unenroll from programme.[/red]")
            else:
                console.print("[red]Invalid selection.[/red]")
        except ValueError:
            console.print("[red]Please enter a valid number.[/red]")

    def select_employee(self):
        while True:
            employee_id = self.get_input("Enter employee ID: ", required=True)
            if employee_id is None:
                return None
            try:
                employee_id = int(employee_id)
                if employee_id in self.employees:
                    return employee_id
                console.print("[red]Employee ID not found.[/red]")
            except ValueError:
                console.print("[red]Please enter a valid ID.[/red]")

    def modify_employee(self):
        """Modify an employee's information"""
        console.print("[italic]Enter 'back' or '0' at any time to cancel[/italic]\n")
        employee_id = self.select_employee()
        if not employee_id:
            return

        employee = self.employees[employee_id]
        self.display_employee_table([employee])
        action_logger.info(f"Displayed employee {employee_id} for modification")

        console.print("\n[bold]What would you like to modify?[/bold]")
        console.print("1. Name\n2. Employee ID\n3. Email\n4. Department\n5. Status")
        choice = self.get_input("Enter choice (1-6): ")
        if choice is None or choice == '6':
            action_logger.info("Modification cancelled")
            return

        if choice == '1':
            new_name = self.get_input(f"Current name: {employee.name}\nNew name: ", required=True)
            if new_name:
                old_name = employee.name
                employee.name = new_name
                self.save_data()
                action_logger.info(f"Modified employee {employee_id}: Changed name from {old_name} to {new_name}")
                console.print("[green]Name updated successfully![/green]")
                self.display_employee_table([employee])

        elif choice == '2':
            while True:
                new_id = self.get_input(f"Current ID: {employee.employee_id}\nNew ID: ", required=True)
                if new_id is None:
                    break
                try:
                    new_id = int(new_id)
                    if new_id == employee.employee_id:
                        console.print("[yellow]Same as current ID. No change made.[/yellow]")
                        break
                    if self.validate_employee_id(new_id):
                        # Remove old employee and add with new ID
                        del self.employees[employee.employee_id]
                        employee.employee_id = new_id
                        self.employees[new_id] = employee
                        self.save_data()
                        action_logger.info(f"Changed employee ID from {employee_id} to {new_id}")
                        console.print("[green]Employee ID updated successfully![/green]")
                        break
                    console.print("[red]Invalid ID. Either exists or not 5 digits.[/red]")
                except ValueError:
                    console.print("[red]Please enter a valid integer.[/red]")

        elif choice == '3':
            while True:
                new_email = self.get_input(f"Current email: {employee.email}\nNew email: ", required=True)
                if new_email is None:
                    break
                if self.validate_email(new_email) or new_email.lower() == employee.email:
                    old_email = employee.email
                    employee.email = new_email.lower()
                    self.save_data()
                    action_logger.info(
                        f"Modified employee {employee_id}: Changed email from {old_email} to {new_email}")
                    console.print("[green]Email updated successfully![/green]")
                    break
                console.print("[red]Invalid email format or email already exists.[/red]")

        elif choice == '4':
            new_dept = self.get_input(f"Current department: {employee.department}\nNew department: ", required=True)
            if new_dept:
                old_dept = employee.department
                employee.department = new_dept.title()
                self.save_data()
                action_logger.info(
                    f"Modified employee {employee_id}: Changed department from {old_dept} to {new_dept}"
                )
                console.print("[green]Department updated successfully![/green]")

        elif choice == '5':
            current_status = "Full-time" if employee.full_time_status else "Part-time"
            while True:
                new_status = self.get_input(
                    f"Current status: {current_status}\nNew status (F for Full-time, P for Part-time): ",
                    required=True
                )
                if new_status is None:
                    break
                new_status = new_status.upper()
                if new_status in ['F', 'P']:
                    old_status = employee.full_time_status
                    employee.full_time_status = new_status == 'F'
                    self.save_data()
                    action_logger.info(
                        f"Modified employee {employee_id}: Changed status from {old_status} to {employee.full_time_status}"
                    )
                    console.print("[green]Status updated successfully![/green]")
                    break
                console.print("[red]Please enter F or P.[/red]")

        else:
            console.print("[red]Invalid choice.[/red]")

    def delete_employee(self):
        """Delete an employee from the system"""
        console.print("\n[bold blue]Delete Employee[/bold blue]")
        employee_id = self.select_employee()
        if not employee_id:
            return

        employee = self.employees[employee_id]
        employee.display_details()

        confirm = self.get_input(
            f"\n[red]WARNING:[/red] Are you sure you want to delete {employee.name}? (yes/no): ",
            required=True
        )
        if confirm and confirm.lower() == 'yes':
            del self.employees[employee_id]
            self.save_data()

            # Also remove from badges database if it exists
            try:
                with shelve.open('badges_db') as badges_db:
                    if str(employee_id) in badges_db:
                        del badges_db[str(employee_id)]
            except Exception as e:
                system_logger.error(f"Error deleting employee badges: {str(e)}")

            action_logger.warning(f"Deleted employee: {employee.name} (ID: {employee_id})")
            console.print(f"[green]Employee {employee.name} deleted successfully![/green]")
        else:
            console.print("[yellow]Deletion cancelled.[/yellow]")

    def bubble_sort_by_department(self):
        """Display employees sorted by department with full information"""
        employee_list = list(self.employees.values())
        n = len(employee_list)

        # Bubble sort implementation with logging
        action_logger.info("Starting bubble sort by department")
        for i in range(n):
            for j in range(0, n - i - 1):
                # Sort by department, then by employee ID
                if (employee_list[j].department > employee_list[j + 1].department or
                        (employee_list[j].department == employee_list[j + 1].department and
                         employee_list[j].employee_id > employee_list[j + 1].employee_id)):
                    employee_list[j], employee_list[j + 1] = employee_list[j + 1], employee_list[j]

        console.print("\n[bold blue]Employees Sorted by Department (A-Z)[/bold blue]")
        self.display_employee_table(employee_list)
        action_logger.info(f"Completed bubble sort for {len(employee_list)} employees")

    def sort_by_status(self):
        """Display employees sorted by employment status (full-time first) using insertion sort"""
        employee_list = list(self.employees.values())

        # Insertion sort implementation with logging
        action_logger.info("Starting insertion sort by status")
        for i in range(1, len(employee_list)):
            key = employee_list[i]
            j = i - 1
            # Sort by status (full-time first) and then by employee ID
            while j >= 0 and (
                    (employee_list[j].full_time_status < key.full_time_status) or
                    (employee_list[j].full_time_status == key.full_time_status and employee_list[
                        j].employee_id > key.employee_id)
            ):
                employee_list[j + 1] = employee_list[j]
                j -= 1
            employee_list[j + 1] = key

        console.print("\n[bold blue]Employees Sorted by Employment Status[/bold blue]")
        self.display_employee_table(employee_list)
        action_logger.info(f"Completed status sort for {len(employee_list)} employees")

    def selection_sort_by_programmes(self):
        """Display employees sorted by number of programmes with full information"""
        employee_list = list(self.employees.values())
        n = len(employee_list)

        # Selection sort implementation with logging
        action_logger.info("Starting selection sort by programmes")
        for i in range(n):
            min_idx = i
            for j in range(i + 1, n):
                # Sort by number of programmes (descending), then by employee ID (ascending)
                if (len(employee_list[j].enrolled_programmes) > len(employee_list[min_idx].enrolled_programmes) or
                        (len(employee_list[j].enrolled_programmes) == len(
                            employee_list[min_idx].enrolled_programmes) and
                         employee_list[j].employee_id < employee_list[min_idx].employee_id)):
                    min_idx = j
            employee_list[i], employee_list[min_idx] = employee_list[min_idx], employee_list[i]

        console.print("\n[bold blue]Employees Sorted by Number of Programmes[/bold blue]")
        self.display_employee_table(employee_list)
        action_logger.info(f"Completed selection sort for {len(employee_list)} employees")

    def search_employee(self):
        console.print("\n[bold blue]Search Employee[/bold blue]")
        console.print("1. By ID\n2. By Name")
        choice = self.get_input("Choose search method (1-2): ")
        if choice is None:
            return

        if choice == '1':
            employee_id = self.select_employee()
            if employee_id:
                action_logger.info(f"Searched for employee by ID: {employee_id}")
                self.display_employee_table([self.employees[employee_id]])
        elif choice == '2':
            name = self.get_input("Enter name (or part): ")
            if name is None:
                return
            name = name.lower()
            found = []
            for emp in self.employees.values():
                if name in emp.name.lower():
                    found.append(emp)

            if found:
                action_logger.info(f"Searched for employees by name: '{name}' - found {len(found)} matches")
                self.display_employee_table(found)
            else:
                console.print("[yellow]No matching employees found.[/yellow]")
                action_logger.info(f"Searched for employees by name: '{name}' - no matches")
        else:
            console.print("[red]Invalid choice.[/red]")
            action_logger.warning("Invalid search choice selected")

    def filter_by_programme(self):
        """Filter employees by training programme"""
        console.print("\n[bold blue]Filter by Training Programme[/bold blue]")
        programme = self.get_input("Enter programme name to filter: ", required=True)
        if not programme:
            return

        programme_lower = programme.lower()
        filtered = []
        for emp in self.employees.values():
            if any(p.lower() == programme_lower for p in emp.enrolled_programmes):
                filtered.append(emp)

        if filtered:
            # Sort filtered results by employee ID
            filtered.sort(key=lambda x: x.employee_id)
            console.print(f"\n[bold]Employees enrolled in {programme}:[/bold]")
            self.display_employee_table(filtered)
            action_logger.info(f"Filtered employees by programme: {programme}")
        else:
            console.print(f"[yellow]No employees enrolled in {programme}.[/yellow]")
            action_logger.info(f"No employees found for programme filter: {programme}")

    def login(self):
        console.print("\n[bold blue]Login[/bold blue]")
        console.print("1. Admin\n2. Employee\n3. Biometric Login\n4. Exit")

        while True:
            choice = self.get_input("Enter choice (1-4): ", required=True)
            if choice is None:
                continue

            if choice == '3':
                # Biometric login
                employee_id = self.select_employee()
                if not employee_id:
                    continue

                if employee_id not in self.biometric_auth.facial_profiles:
                    console.print("[yellow]No biometric profile found. Please enroll first.[/yellow]")
                    enroll = self.get_input("Enroll now? (Y/N): ")
                    if enroll and enroll.upper() == 'Y':
                        if self.biometric_auth.enroll_user(employee_id):
                            if self.biometric_auth.authenticate(employee_id):
                                self.logged_in_user = employee_id
                                return True
                    continue

                if self.biometric_auth.authenticate(employee_id):
                    self.logged_in_user = employee_id
                    return True
                continue

            elif choice == '1':
                # Admin login
                username = self.get_input("Username: ", required=True)
                if username is None:
                    continue

                password = self.get_input("Password: ", required=True)
                if password is None:
                    continue

                if username == self.admin_username and password == self.admin_password:
                    self.logged_in_user = "admin"
                    action_logger.info("Admin logged in")
                    console.print("\n[green]Admin login successful![/green]")
                    return True
                else:
                    console.print("[red]Invalid credentials.[/red]")
                    return False

            elif choice == '2':
                # Employee login
                employee_id = self.select_employee()
                if not employee_id:
                    console.print("[red]Invalid Employee ID.[/red]")
                    return False

                employee = self.employees[employee_id]

                if employee.password is None:
                    console.print("\n[yellow]First-time login. Set your password.[/yellow]")
                    while True:
                        password = self.get_input("Set password: ", required=True)
                        if password is None:
                            break

                        confirm = self.get_input("Confirm password: ", required=True)
                        if confirm is None:
                            break

                        if password == confirm:
                            employee.password = password
                            self.save_data()
                            self.logged_in_user = employee_id
                            action_logger.info(f"Employee {employee_id} set password")
                            console.print("\n[green]Password set and login successful![/green]")
                            return True
                        else:
                            console.print("[red]Passwords do not match. Try again.[/red]")
                else:
                    password = self.get_input("Password: ", required=True)
                    if password is None:
                        continue

                    if password == employee.password:
                        self.logged_in_user = employee_id
                        action_logger.info(f"Employee {employee_id} logged in")
                        console.print("\n[green]Login successful![/green]")
                        return True
                    else:
                        console.print("[red]Invalid password.[/red]")
                        return False

            elif choice == '4':
                self.save_data()
                console.print("\n[blue]Goodbye![/blue]")
                sys.exit(0)
            else:
                console.print("[red]Invalid choice.[/red]")
                continue

    def show_employee_details(self, employee):
        """Display all details for the logged-in employee in list format"""
        console.print(f"\n[bold blue]Employee Details - {employee.name}[/bold blue]")
        console.print("─" * 50)  # Divider line

        # Get badge information
        try:
            with shelve.open('badges_db', flag='r') as badges_db:
                badges = badges_db.get(str(employee.employee_id), [])
                badge_count = len(badges)
                points = self.calculate_points(badges)
                badge_names = ", ".join(badges) if badges else "None"
        except Exception as e:
            console.print(f"[red]Error accessing badges: {str(e)}[/red]")
            badge_count = 0
            points = 0
            badge_names = "None"

        # Display details in list format
        console.print(f"[bold]Employee ID:[/bold] {employee.employee_id}")
        console.print(f"[bold]Name:[/bold] {employee.name}")
        console.print(f"[bold]Email:[/bold] {employee.email}")
        console.print(f"[bold]Department:[/bold] {employee.department}")
        console.print(
            f"[bold]Status:[/bold] {'[green]Full-time[/green]' if employee.full_time_status else '[yellow]Part-time[/yellow]'}")

        # Enrolled Programmes
        console.print("\n[bold]Enrolled Programmes:[/bold]")
        if employee.enrolled_programmes:
            for i, programme in enumerate(employee.enrolled_programmes, 1):
                console.print(f"  {i}. {programme}")
        else:
            console.print("  No programmes enrolled")

        # Badges
        console.print(f"\n[bold]Badges:[/bold] {badge_count} (Total Points: [green]{points}[/green])")
        if badge_count > 0:
            console.print("  " + badge_names)
        else:
            console.print("  No badges earned")

        # Pending Requests
        console.print("\n[bold]Pending Requests:[/bold]")
        if employee.pending_requests:
            for req in employee.pending_requests:
                status_color = "yellow" if req['status'] == 'Pending' else "green" if req[
                                                                                          'status'] == 'Approved' else "red"
                console.print(
                    f"  • {req['programme']} ([{status_color}]{req['status']}[/{status_color}]) - {req['date']}")
        else:
            console.print("  No pending requests")

        console.print("─" * 50)  # Divider line

    def submit_feedback(self, employee):
        if not employee.enrolled_programmes:
            console.print("[yellow]No programmes to provide feedback.[/yellow]")
            return

        console.print("\n[bold blue]Submit Feedback[/bold blue]")
        for i, prog in enumerate(employee.enrolled_programmes, 1):
            console.print(f"{i}. {prog}")

        prog_choice = self.get_input("Select programme: ", required=True)
        if prog_choice is None:
            return

        try:
            prog_choice = int(prog_choice) - 1
            if 0 <= prog_choice < len(employee.enrolled_programmes):
                programme = employee.enrolled_programmes[prog_choice]
                feedback = self.get_input("Your feedback: ", required=True)
                if feedback is None:
                    return

                while True:
                    rating = self.get_input("Rating (1-5): ", required=True)
                    if rating is None:
                        return
                    try:
                        rating = int(rating)
                        if 1 <= rating <= 5:
                            break
                        console.print("[red]Rating must be 1-5.[/red]")
                    except ValueError:
                        console.print("[red]Enter a number.[/red]")

                employee.add_feedback(programme, feedback, rating)
                self.save_data()
                console.print("[green]Thank you for your feedback![/green]")
            else:
                console.print("[red]Invalid selection.[/red]")
        except ValueError:
            console.print("[red]Enter a valid number.[/red]")

    def request_enrollment(self, employee):
        programme = self.get_input("Programme name to request: ", required=True)
        if programme is None:
            return

        if employee.request_enrollment(programme):
            self.save_data()
            console.print(f"\n[green]Request submitted for {programme}.[/green]")
        else:
            console.print(f"\n[yellow]Already enrolled or pending for {programme}.[/yellow]")

    def change_password(self, employee):
        current = self.get_input("Current password: ", required=True)
        if current is None:
            return

        if current != employee.password:
            console.print("[red]Incorrect password.[/red]")
            return

        new_pass = self.get_input("New password: ", required=True)
        if new_pass is None:
            return

        confirm = self.get_input("Confirm password: ", required=True)
        if confirm is None:
            return

        if new_pass == confirm:
            employee.password = new_pass
            self.save_data()
            action_logger.info(f"Employee {employee.employee_id} changed password")
            console.print("[green]Password changed![/green]")
        else:
            console.print("[red]Passwords don't match.[/red]")

    def view_employee_badges(self, employee):
        """Display badges for the logged-in employee"""
        try:
            with shelve.open('badges_db', flag='r') as badges_db:
                badges = badges_db.get(str(employee.employee_id), [])

                console.print("\n[bold blue]Your Badges[/bold blue]")
                if not badges:
                    console.print("[yellow]No badges earned yet.[/yellow]")
                    return

                table = Table(show_header=True, header_style="bold blue", show_lines=True)
                table.add_column("Badge", style="cyan")
                table.add_column("Points", style="green")

                # Define badge values for point calculation
                badge_values = {
                    'Fast Learner': 20,
                    'Innovation Learner': 15,
                    'Most Passionate': 10,
                    'Most Initiative': 25,
                    # Default value for unknown badges
                    'default': 10
                }

                for badge in badges:
                    # Calculate points for each badge
                    points = badge_values.get(badge, badge_values['default'])
                    table.add_row(badge, str(points))

                console.print(table)
                console.print(f"\n[green]Total Points: {self.calculate_points(badges)}[/green]")

        except Exception as e:
            console.print(f"[red]Error viewing badges: {str(e)}[/red]")
            system_logger.error(f"Error viewing badges for {employee.employee_id}: {str(e)}")

    def view_feedback(self):
        """Display feedback in a properly formatted table with solid lines and consistent columns"""
        console.print("\n[bold blue]Programme Feedback[/bold blue]")

        # Collect all feedback data
        feedback_data = []
        for emp in self.employees.values():
            if emp.feedback:
                for fb in emp.feedback:
                    feedback_data.append({
                        'employee_id': emp.employee_id,
                        'name': emp.name,
                        'programme': fb['programme'],
                        'rating': fb['rating'],
                        'feedback': fb['feedback'],
                        'date': fb['date']
                    })

        if not feedback_data:
            console.print("[yellow]No feedback available.[/yellow]")
            return

        # Sort feedback by employee ID (ascending)
        feedback_data.sort(key=lambda x: x['employee_id'])

        # Prepare table data with proper formatting
        table_data = []
        for fb in feedback_data:
            # Convert rating to stars
            rating = int(fb['rating'])
            stars = "★" * rating + "☆" * (5 - rating)

            # Clean up feedback text
            feedback_text = fb['feedback'].replace('\n', ' ').strip()
            if len(feedback_text) > 50:
                feedback_text = feedback_text[:47] + "..."

            # Format date
            try:
                formatted_date = datetime.strptime(fb['date'], '%Y-%m-%d %H:%M:%S').strftime('%d %b %Y %H:%M')
            except:
                formatted_date = fb['date']  # Fallback if parsing fails

            table_data.append([
                fb['employee_id'],
                fb['name'][:20],  # Limit name length
                fb['programme'][:20],  # Limit programme length
                stars,
                feedback_text,
                formatted_date
            ])

        # Define headers
        headers = [
            "ID",
            "Name",
            "Programme",
            "Rating",
            "Feedback",
            "Date"
        ]

        # Print using pretty format with adjusted column widths
        action_logger.info("Displayed feedback records")

        # Create custom column alignment
        colalign = ("left", "left", "left", "left", "left", "left")

        console.print(tabulate(table_data, headers=headers, tablefmt="fancy_grid", colalign=colalign))

    def export_data(self):
        """Export employee data with badges information"""
        console.print("\n[bold blue]Export Employee Data[/bold blue]")

        try:
            # Prepare data and sort by employee ID
            table_data = []
            with shelve.open('badges_db', flag='r') as badges_db:
                # Create list of employees sorted by ID
                sorted_employees = sorted(self.employees.values(), key=lambda emp: emp.employee_id)

                for emp in sorted_employees:
                    badges = badges_db.get(str(emp.employee_id), [])

                    table_data.append([
                        emp.employee_id,
                        emp.name,
                        emp.department,
                        "Full-time" if emp.full_time_status else "Part-time",
                        emp.email,
                        ", ".join(emp.enrolled_programmes) if emp.enrolled_programmes else "None",
                        len(badges),
                        self.calculate_points(badges),
                        ", ".join(badges) if badges else "None"
                    ])

            if not table_data:
                console.print("[yellow]No employee data to export.[/yellow]")
                return

            # Display preview
            headers = ["ID", "Name", "Department", "Status", "Email", "Programmes", "Badges", "Points", "Badge Names"]

            preview_table = Table(show_header=True, header_style="bold blue", show_lines=True, expand=True)
            for header in headers:
                preview_table.add_column(header)

            for row in table_data[:5]:  # Show first 5 as preview
                preview_table.add_row(*[str(item) for item in row])

            console.print(preview_table)

            if len(table_data) > 5:
                console.print(f"[dim]Showing 5 of {len(table_data)} records...[/dim]")

            # Export options
            console.print("\n1. Export to Excel\n2. Export to PDF\n3. Back")
            choice = self.get_input("Select export format: ")

            if choice == '1':
                self.export_to_excel(sorted_employees)  # Pass sorted employees
            elif choice == '2':
                self.export_to_pdf(table_data, headers)

        except Exception as e:
            console.print(f"[red]Error preparing export data: {str(e)}[/red]")
            system_logger.error(f"Export preparation failed: {str(e)}")

    def export_to_excel(self, sorted_employees):
        """Export employee data to Excel with all requested fields"""
        try:
            # Prepare data with all required fields, already sorted
            data = []
            with shelve.open('badges_db', flag='r') as badges_db:
                for emp in sorted_employees:
                    # Get badge information
                    badges = badges_db.get(str(emp.employee_id), [])
                    badge_count = len(badges)
                    points = self.calculate_points(badges)
                    badge_names = ", ".join(badges) if badges else "None"

                    data.append({
                        'ID': emp.employee_id,
                        'Name': emp.name,
                        'Department': emp.department,
                        'Status': 'Full-time' if emp.full_time_status else 'Part-time',
                        'Email': emp.email,
                        'Programmes': ', '.join(emp.enrolled_programmes) if emp.enrolled_programmes else 'None',
                        'Badges': badge_count,
                        'Points': points,
                        'Badge Names': badge_names
                    })

            # Create DataFrame
            df = pd.DataFrame(data)

            # Ensure exports directory exists
            os.makedirs('exports', exist_ok=True)

            # Generate filename with timestamp
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            export_path = os.path.join('exports', f'employee_export_{timestamp}.xlsx')

            # Export to Excel
            try:
                # Try with openpyxl first
                df.to_excel(export_path, index=False, engine='openpyxl')
            except ImportError:
                # Fallback to default engine
                df.to_excel(export_path, index=False)

            action_logger.info(f"Exported data to Excel: {export_path}")
            console.print(f"[green]Data successfully exported to:[/green] [bold]{export_path}[/bold]")

        except Exception as e:
            console.print(f"[red]Error exporting to Excel: {str(e)}[/red]")
            system_logger.error(f"Excel export failed: {str(e)}")
            if "openpyxl" in str(e):
                console.print("[yellow]Note: Install openpyxl for better Excel support: pip install openpyxl[/yellow]")

    def export_to_pdf(self, table_data, headers):
        """Export data to PDF file"""
        try:
            # Create PDF
            pdf = FPDF(orientation='L')  # Landscape
            pdf.set_auto_page_break(auto=True, margin=15)
            pdf.add_page()

            # Title
            pdf.set_font("Helvetica", 'B', 16)
            pdf.cell(0, 10, "Employee Training Report", 0, 1, 'C')
            pdf.set_font("Helvetica", '', 10)
            pdf.cell(0, 10, f"Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", 0, 1, 'C')
            pdf.ln(10)

            # Calculate column widths
            col_widths = [15, 30, 25, 20, 50, 40, 15, 15, 40]  # Adjusted for ID first

            # Header row
            pdf.set_fill_color(200, 220, 255)
            pdf.set_font("Helvetica", 'B', 10)
            for i, header in enumerate(headers):
                pdf.cell(col_widths[i], 10, header, 1, 0, 'C', True)
            pdf.ln()

            # Data rows (already sorted)
            pdf.set_font("Helvetica", '', 8)
            fill = False
            for row in table_data:
                fill = not fill
                pdf.set_fill_color(240, 240, 240) if fill else pdf.set_fill_color(255, 255, 255)

                for i, item in enumerate(row):
                    pdf.cell(col_widths[i], 10, str(item), 1, 0, 'L', fill)
                pdf.ln()

                if pdf.get_y() > 270:  # New page if near bottom
                    pdf.add_page()
                    # Redraw header
                    pdf.set_fill_color(200, 220, 255)
                    pdf.set_font("Helvetica", 'B', 10)
                    for i, header in enumerate(headers):
                        pdf.cell(col_widths[i], 10, header, 1, 0, 'C', True)
                    pdf.ln()
                    pdf.set_font("Helvetica", '', 8)

            # Save file
            export_path = os.path.join('exports', f'employee_export_{datetime.now().strftime("%Y%m%d_%H%M%S")}.pdf')
            pdf.output(export_path)

            console.print(f"[green]Successfully exported to {export_path}[/green]")
            action_logger.info(f"Exported employee data to PDF: {export_path}")

        except Exception as e:
            console.print(f"[red]Error exporting to PDF: {str(e)}[/red]")
            system_logger.error(f"PDF export failed: {str(e)}")

    def manage_badges(self):
        """Admin function to add/remove badges for employees"""
        console.print("[italic]Enter 'back' or '0' at any time to cancel[/italic]\n")

        # Define available badge types with points
        badge_types = {
            'Fast Learner': 20,
            'Innovation Learner': 15,
            'Most Passionate': 10,
            'Most Initiative': 25,
        }

        employee_id = self.select_employee()
        if not employee_id:
            return

        employee = self.employees[employee_id]

        try:
            with shelve.open('badges_db') as badges_db:
                badges = badges_db.get(str(employee_id), [])

                while True:
                    console.print(f"\n[bold]Current Badges for {employee.name}:[/bold]")
                    if badges:
                        for i, badge in enumerate(badges, 1):
                            console.print(f"{i}. [cyan]{badge}[/cyan]")
                    else:
                        console.print("[yellow]No badges assigned[/yellow]")

                    # Display available badge types
                    console.print("\n[bold]Available Badge Types:[/bold]")
                    for badge, points in badge_types.items():
                        console.print(f"- {badge}: [yellow]{points}[/yellow] points")

                    console.print("\n1. Add Badge\n2. Remove Badge\n3. Back")
                    choice = self.get_input("Select option: ")

                    if choice == '1':
                        console.print("\n[bold]Available Badges:[/bold]")
                        for i, (badge, points) in enumerate(badge_types.items(), 1):
                            console.print(f"{i}. {badge} ({points} points)")

                        badge_choice = self.get_input("\nSelect badge to add (number or name): ")
                        if badge_choice:
                            try:
                                # Try numeric selection first
                                badge_idx = int(badge_choice) - 1
                                if 0 <= badge_idx < len(badge_types):
                                    badge_name = list(badge_types.keys())[badge_idx]
                                else:
                                    raise ValueError
                            except ValueError:
                                # Fall back to name input
                                badge_name = badge_choice.title()

                            if badge_name in badge_types:
                                if badge_name not in badges:
                                    badges.append(badge_name)
                                    badges_db[str(employee_id)] = badges
                                    console.print(f"\n[green]Added badge: {badge_name}[/green]")
                                    action_logger.info(f"Added badge '{badge_name}' to employee {employee_id}")
                                else:
                                    console.print("[yellow]Employee already has this badge[/yellow]")
                            else:
                                # Allow custom badges with default points
                                confirm = self.get_input(
                                    f"'{badge_name}' is not a standard badge. Add anyway? (Y/N): "
                                )
                                if confirm and confirm.upper() == 'Y':
                                    badges.append(badge_name)
                                    badges_db[str(employee_id)] = badges
                                    console.print(f"\n[green]Added custom badge: {badge_name}[/green]")
                                    action_logger.info(f"Added custom badge '{badge_name}' to employee {employee_id}")

                    elif choice == '2':
                        if not badges:
                            console.print("[yellow]No badges to remove[/yellow]")
                            continue

                        badge_choice = self.get_input("Enter badge number to remove: ")
                        if badge_choice:
                            try:
                                idx = int(badge_choice) - 1
                                if 0 <= idx < len(badges):
                                    removed = badges.pop(idx)
                                    badges_db[str(employee_id)] = badges
                                    console.print(f"\n[red]Removed badge: {removed}[/red]")
                                    action_logger.info(f"Removed badge '{removed}' from employee {employee_id}")
                                else:
                                    console.print("[red]Invalid selection[/red]")
                            except ValueError:
                                console.print("[red]Please enter a valid number[/red]")

                    elif choice == '3':
                        break

        except Exception as e:
            console.print(f"[red]Error managing badges: {str(e)}[/red]")
            system_logger.error(f"Badge management failed: {str(e)}")

    def calculate_points(self, badges):
        """Calculate points based on badges with different values"""
        badge_values = {
            'excellence': 20,
            'innovation': 15,
            'teamwork': 10,
            'leadership': 25
        }

        total = 0
        for badge in badges:
            total += badge_values.get(badge.lower(), 10)  # Default 10 points for unknown badges

        return total

    def display_export_preview(self, data):
        """Display a preview of the exported data in console"""
        console.print("\n[bold blue]Export Preview[/bold blue]")

        if not data:
            console.print("[yellow]No data to display.[/yellow]")
            return

        # Prepare table data
        headers = ["Name", "ID", "Department", "Status", "Email", "Programmes", "Badges", "Points", "Badge Names"]
        table_data = []

        for row in data[:5]:  # Show first 5 rows as preview
            table_data.append([
                row['Name'],
                row['ID'],
                row['Department'],
                row['Status'],
                row['Email'],
                row['Programmes'],
                row['Badges'],
                row['Points'],
                row['Badge Names'][:30] + "..." if len(row['Badge Names']) > 30 else row['Badge Names']
            ])

        # Create and display table
        table = Table(show_header=True, header_style="bold blue", show_lines=True, expand=True)
        for header in headers:
            table.add_column(header)

        for row in table_data:
            table.add_row(*[str(item) for item in row])

        console.print(table)

        if len(data) > 5:
            console.print(f"[dim]Showing 5 of {len(data)} records...[/dim]")

    def view_pending_requests(self):
        console.print("\n[bold blue]Pending Requests[/bold blue]")
        pending_requests = []

        for emp in self.employees.values():
            for req in emp.pending_requests:
                if req['status'] == 'Pending':
                    pending_requests.append({
                        'employee_id': emp.employee_id,
                        'name': emp.name,
                        'programme': req['programme'],
                        'date': req['date']
                    })

        if not pending_requests:
            console.print("[yellow]No pending requests.[/yellow]")
            return

        table = Table(show_header=True, header_style="bold blue", show_lines=True, expand=True)
        table.add_column("Employee ID", style="dim", width=10)
        table.add_column("Name", width=20)
        table.add_column("Programme", width=30)
        table.add_column("Date", width=20)
        table.add_column("Actions", width=20)

        for req in pending_requests:
            table.add_row(
                str(req['employee_id']),
                req['name'],
                req['programme'],
                req['date'],
                "[green]Approve[/green] / [red]Reject[/red]"
            )

        console.print(table)

        while True:
            action = self.get_input("\nEnter 'approve ID' or 'reject ID' (or 'back'): ")
            if action is None or action.lower() == 'back':
                break

            parts = action.lower().split()
            if len(parts) == 2 and parts[0] in ['approve', 'reject']:
                try:
                    emp_id = int(parts[1])
                    employee = self.employees.get(emp_id)
                    if employee:
                        for req in employee.pending_requests:
                            if req['status'] == 'Pending':
                                if parts[0] == 'approve':
                                    employee.add_training_programme(req['programme'])
                                    req['status'] = 'Approved'
                                    action_logger.info(f"Approved {emp_id}'s request for {req['programme']}")
                                    console.print(f"[green]Approved {employee.name}'s request.[/green]")
                                else:
                                    req['status'] = 'Rejected'
                                    action_logger.info(f"Rejected {emp_id}'s request for {req['programme']}")
                                    console.print(f"[red]Rejected {employee.name}'s request.[/red]")
                                self.save_data()
                                break
                        else:
                            console.print("[yellow]No pending request found.[/yellow]")
                    else:
                        console.print("[red]Employee not found.[/red]")
                except ValueError:
                    console.print("[red]Invalid employee ID.[/red]")
            else:
                console.print("[red]Invalid command.[/red]")

    def manage_requests_menu(self):
        """Submenu for managing employee requests"""
        while True:
            console.print("\n[bold blue]Employee Requests Management[/bold blue]")
            console.print("1. Add Request\n2. View Queue Statistics\n3. Process Next Request")
            console.print("4. View All Requests\n5. Back")

            choice = self.get_input("Enter choice (1-5): ")
            if choice == '1':
                self.add_employee_request()
            elif choice == '2':
                self.view_request_statistics()
            elif choice == '3':
                self.process_next_request()
            elif choice == '4':
                self.display_requests_table(self.request_queue.requests)
            elif choice == '5':
                break
            else:
                console.print("[red]Invalid choice.[/red]")

    def show_dashboard(self):
        """Display a comprehensive dashboard with system statistics"""
        console.print("\n[bold blue]System Dashboard[/bold blue]")

        # Calculate statistics
        total_employees = len(self.employees)
        full_time = sum(1 for emp in self.employees.values() if emp.full_time_status)
        part_time = total_employees - full_time

        # Most common programme
        programme_counts = {}
        for emp in self.employees.values():
            for prog in emp.enrolled_programmes:
                programme_counts[prog] = programme_counts.get(prog, 0) + 1

        most_common_prog = max(programme_counts.items(), key=lambda x: x[1]) if programme_counts else ("None", 0)

        # Pending requests
        pending_requests = self.request_queue.size()

        # Create dashboard table
        dashboard = Table(show_header=True, header_style="bold blue", show_lines=True)
        dashboard.add_column("Metric", style="bold", width=30)
        dashboard.add_column("Value", style="green", width=20)

        dashboard.add_row("Total Employees", str(total_employees))
        dashboard.add_row("Full-time Employees", str(full_time))
        dashboard.add_row("Part-time Employees", str(part_time))
        dashboard.add_row("Most Common Programme", f"{most_common_prog[0]} ({most_common_prog[1]} enrollments)")
        dashboard.add_row("Pending Requests", str(pending_requests))

        # Department distribution
        dept_counts = {}
        for emp in self.employees.values():
            dept_counts[emp.department] = dept_counts.get(emp.department, 0) + 1

        dept_distribution = "\n".join([f"{dept}: {count}" for dept, count in sorted(dept_counts.items())])
        dashboard.add_row("Department Distribution", dept_distribution)

        # Programme enrollment stats
        enrolled_counts = [len(emp.enrolled_programmes) for emp in self.employees.values()]
        avg_enrollments = sum(enrolled_counts) / total_employees if total_employees > 0 else 0
        max_enrollments = max(enrolled_counts) if enrolled_counts else 0

        dashboard.add_row("Avg Programmes per Employee", f"{avg_enrollments:.1f}")
        dashboard.add_row("Max Programmes (one employee)", str(max_enrollments))

        console.print(dashboard)

        # Recent activity
        console.print("\n[bold]Recent Activity[/bold]")
        try:
            with open('logs/employee.log.txt', 'r') as f:
                lines = f.readlines()[-5:]  # Get last 5 log entries
                for line in lines:
                    console.print(f"[dim]{line.strip()}[/dim]")
        except FileNotFoundError:
            console.print("[yellow]No recent activity found.[/yellow]")

        # Update and display real-time metrics
        self.real_time_dashboard.update_metrics()
        self.real_time_dashboard.display_trends()

    def admin_menu(self):
        while True:
            console.print("\n[bold blue]Admin Menu[/bold blue]")
            console.print("0. Back to Main Menu\n1. View Employees\n2. Add Employee\n3. Modify Employee")
            console.print("4. Delete Employee\n5. Enroll Employee\n6. Unenroll Employee")
            console.print("7. Quick Sort by Department/Name\n8. Merge Sort by Programmes/ID")
            console.print("9. Sort by Status\n10. Search Employee\n11. Filter by Programme")
            console.print("12. Manage Requests\n13. View Feedback\n14. Manage Badges")
            console.print("15. Export Data\n16. View Dashboard\n17. Logout\n18. Exit")

            choice = self.get_input("Enter choice (1-18): ")
            if choice is None:
                continue
            if choice == '0' or choice.lower() == 'back':
                break
            if choice == '1':
                self.display_all_employees()
            elif choice == '2':
                self.add_employee()
            elif choice == '3':
                self.modify_employee()
            elif choice == '4':
                self.delete_employee()
            elif choice == '5':
                self.enrol_programme()
            elif choice == '6':
                self.unenroll_programme()
            elif choice == '7':
                self.display_sorted_by_department()  # Quick sort
            elif choice == '8':
                self.display_sorted_by_programmes()  # Merge sort
            elif choice == '9':
                self.sort_by_status()
            elif choice == '10':
                self.search_employee()
            elif choice == '11':
                self.filter_by_programme()
            elif choice == '12':
                self.manage_requests_menu()
            elif choice == '13':
                self.view_feedback()
            elif choice == '14':
                self.manage_badges()
            elif choice == '15':
                self.export_data()
            elif choice == '16':
                self.show_dashboard()
            elif choice == '17':
                action_logger.info("Admin logged out")
                self.logged_in_user = None
                console.print("[green]Logged out.[/green]")
                break
            elif choice == '18':
                self.save_data()
                console.print("\n[blue]Goodbye![/blue]")
                sys.exit(0)
            else:
                console.print("[red]Invalid choice.[/red]")

    def employee_menu(self):
        """Menu for regular employees after login"""
        employee = self.employees[self.logged_in_user]

        while True:
            console.print(f"\n[bold blue]Employee Menu - {employee.name}[/bold blue]")
            console.print("1. View Employee Details\n2. Submit Feedback\n3. Request Programme Enrollment")
            console.print("4. View Badges\n5. Change Password\n6. Logout")

            choice = self.get_input("Enter choice (1-6): ")
            if choice is None:
                continue

            if choice == '1':
                self.show_employee_details(employee)
            elif choice == '2':
                self.submit_feedback(employee)
            elif choice == '3':
                self.request_enrollment(employee)
            elif choice == '4':
                self.view_employee_badges(employee)
            elif choice == '5':
                self.change_password(employee)
            elif choice == '6':
                action_logger.info(f"Employee {employee.employee_id} logged out")
                self.logged_in_user = None
                console.print("[green]Logged out successfully![/green]")
                break
            else:
                console.print("[red]Invalid choice.[/red]")


def show_banner():
    banner_text = pyfiglet.figlet_format("Employee Academy", font="slant")
    console.print(banner_text, style="bold blue")
    console.rule("[bold cyan]Training Management System[/bold cyan]")


def main():
    system = TrainingManagementSystem()
    show_banner()

    while True:
        if not system.logged_in_user:
            console.print("\n[bold blue]Main Menu[/bold blue]")
            console.print("1. Login\n2. Exit")
            choice = system.get_input("Enter choice (1-2): ")
            if choice is None:
                continue

            if choice == '1':
                if system.login():
                    if system.logged_in_user == "admin":
                        system.admin_menu()
                    else:
                        system.employee_menu()
            elif choice == '2':
                system.save_data()
                console.print("[blue]Goodbye![/blue]")
                break
            else:
                console.print("[red]Invalid choice.[/red]")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        console.print("\n[red]Program interrupted. Exiting...[/red]")
        sys.exit(0)
    except Exception as e:
        console.print(f"\n[red]Error: {str(e)}[/red]")
        sys.exit(1)
